% uw-wkrpt-se.tex - An example work report that uses uw-wkrpt.cls
% Copyright (C) 2002,2003  Simon Law
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We begin by calling the workreport class which includes all the
% definitions for the macros we will use.
\documentclass[se]{uw-wkrpt}

% LaTeX preamble: load some packages to add functionality
\usepackage{graphicx} % Include graphic importing

\usepackage[T1]{fontenc} % Better fonts
\usepackage{ae,aecompl}

\usepackage{indentfirst} % Indent first paragraph of each section

\usepackage[titletoc,title]{appendix} % Prefix appendix letters with `Appendix'

\usepackage{amsmath}
%\usepackage{scrextend}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{tkz-graph}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{bytefield}
\usepackage{listings,color}
\usepackage{float}


% Use the algorithmicx package for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}

% Use biblatex for references
\usepackage[style=ieee,sorting=none,dateabbrev=false,backend=biber]{biblatex}
\addbibresource{uw-wkrpt-bib.bib} % Specify the bibliography file

% This needs to be the last package loaded
\usepackage[pdftex]{hyperref} % Generate PDF links and bookmarks.
\hypersetup{
  bookmarks=true,
  bookmarksnumbered=true
}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{code}{%
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

% http://www.martin-demling.de/2011/06/memory-maps-in-latex-using-the-bytefield-package/
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip} % define the height of the memsection
	\bitbox[]{10}{
		\texttt{#1} % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{#2} % print start address
	}
	\bitbox{16}{#4} % print box with caption
}


% Now we will begin writing the document.
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IMPORTANT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% First we, should create a title page.  This is done below:
% Fill in the title of your report.
\title{OS WOW RTX Documentation}

% Fill in your name.
\author{Fasih Awan, Joshua Kalpin, Si Chuang Li, John Zanutto}

% Fill in your student ID number.
\uwid{20414848, 20414492, 20413578, TODO}

% Fill in the name of the PNG file with your signature, or leave unchanged.
\signature{signature}

% Fill in your home address.
\address{123 University Ave. W.\\*
         Waterloo, ON\ \ N2L 3G1}

% Fill in your employer's name.
\employer{SE 350}

% Fill in your employer's city and province.
\employeraddress{Thomas Reidemeister}

% Fill in your school's name.
\school{University of Waterloo}

% Fill in your faculty name.
\faculty{Software Engineering}

% Fill in your student user ID
\userid{fawan, jkalpin, sc6li, jzanutto}

% Fill in your e-mail address.
\email{jrhacker@engmail}

% Fill in your term.
\term{3A}

% Fill in your program.
\program{Software Engineering}

% Fill in the department chair's name.
\chair{Dr.\ A.\ Morton}

% Fill in the department chair's mailing address.
\chairaddress{Software Engineering\\*
              University of Waterloo\\*
	      Waterloo, ON\ \ N2L 3G1}

% If you are writing an "SE-confidential" report, uncomment the next line.
%\confidential{SE-confidential}

% If you want to specify the date, fill it in here.  If you comment out
% this line, today's date will be substituted.
%\date{April 24, 2012}

% Now, we ask LaTeX to generate the title.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \frontmatter will make the \section commands ignore their numbering,
%% it will also use roman page numbers.
\frontmatter

% We continue with required sections, such as the Executive Summary.
\section{Executive Summary}
TODO

% Next, we need to make a Table of Contents, List of Figures and 
% List of Tables.  You will most likely need to run LaTeX twice to
% get these correct.  The first pass for LaTeX to figure out the
% labels, and the second pass to put in the right references.
\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REPORT BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \main will make the \section commands numbered again,
%% it will also use arabic page numbers.
\mainmatter

% You must have an Introduction
\section{Introduction}\label{sec:intro}

\subsection{About}

This report is a detailed design document describing the OS WOW Real-Time Operation System designed by Fasih Awan, Joshua Kalpin, John Zanutto and Si Chuang Li. This operating system was implemented for the Keil MCB1700 board populated with an NXP LPC1768 microcontroller. 

This operating system was created over the span of three months during the creator's 3A term in Software Engineering. It was developed in four parts adding more features each time. The first part involved creating basic memory management and process handling. The second part added the challenge of interrupts and a console. The third part added more processes. Lastly, the fourth part of the project included timing tests and this report.



\subsection{Purpose}

The purpose of this report is to provide the reader with detailed documentation on the OS WOW operating system. This includes the following information. First, the data structures and global variables that the kernel uses. Second, this report will document the APIs that are available to user's of the operation system. Third, details on how interrupts are handled within the operating system will be specified. Fourth, the various system, user and test processes will be explained. Fifth, details on how the operating system is initialized, including memory and processes will be provided. Lastly, there will be details on testing, design challenges and timing analysis on the functions of the operating system.

\section{Global Variables}\label{sec:global}

\section{Kernel API}\label{sec:kernel}

\subsection{Memory}

\subsubsection{\texttt{void* request\_memory\_block()}}

This method takes zero arguments and returns an address to a piece of memory that the caller can use. The returned address points to a continuous block of memory of size \texttt{0x1F4} bytes that the current process can read and write to. Currently, the memory protection unit is disabled so if the process writes outside of the data region indicated in Figure~\ref{fig:memory-block}, then undefined behaviour will occur.

\begin{figure}
\label{fig:memory-block}
\caption{Memory Block}
\begin{bytefield}{}
    \memsection{0x200}{}{1.5}{\texttt{next}} \\
    \memsection{}{}{1.5}{\texttt{prev}} \\
    \begin{rightwordgroup}{Process allocated space of size \texttt{0x1F4}}
    	\memsection{returned pointer}{}{10}{\texttt{data}}
    \end{rightwordgroup} \\
    \memsection{}{0x0}{2}{\texttt{padding = 0xABAD1DEA}} 
\end{bytefield}
\end{figure}

If the system is out of memory, the calling process will be pre-empted and be placed on its priority's memory blocked queue until more memory becomes available (i.e. when another process releases their memory). It is recommended that once the user is finished with their allocated block that they release it otherwise the system will have memory leaks and run out of memory very quickly. See Section~\ref{sec:release-memory-block} for more information.

\subsubsection{\texttt{int32\_t release\_memory\_block(void*)}}
\label{sec:release-memory-block}

This method takes in a pointer returned by \texttt{request\_memory\_block} and deallocate it. If the pointer is invalid such as NULL or out of the range of the RAM, this method returns -1. This method also checks if there are processes blocked on memory with a priority greater than or equal to the calling process. If so, then the current process will get pre-empted and the scheduler will get called instead of continuing with the current process.

\subsubsection{Example Usage of Requesting and Releasing Memory}
\begin{code}
void example_process(void) {
    int* array;
    
    while (1) {
        array = (int*) request_memory_block();
        array[0] = 0xDEADC0DE;
        release_memory_block(array);
    }
}
\end{code}


\section{Interrupts}\label{sec:interupt}

\section{System and User Processes}\label{sec:proc}

\section{Test Processes}\label{sec:testproc}

\section{Initialization}\label{sec:init}

At the start of our OS, we disabled interrupts before we initialize our system, otherwise our interrupt handlers cannot run properly. Once everything was initialized properly, we re-enabled interrupts and called our scheduler to dispatch the first process.

\subsection{System APIs}
The first stage of our initialization was to setup our system APIs. These allowed us to use \texttt{printf}, to use interrupt-driven IO on UART0, to use program-driven IO on UART1 (for debugging), and to receive timer interrupts every second.

\begin{itemize}
	\item \texttt{SystemInit()}
	\item \texttt{init\_printf(putc, NULL)}	
	\item \texttt{uart\_irq\_init(0)}
	\item \texttt{uart1\_init()}
	\item \texttt{timer\_init(0)}
\end{itemize}

As an added bonus, we also enabled the use of our board's LCD screen. From the example code found in uVision's installation directory, we were able to write text and draw basic geometric shapes onto the LCD. Since the LCD API uses polling for IO like UART1, we decided that it was infeasible to use it for system functionalities such as the Wall Clock. Instead, we decided to make the LCD screen display our OS's logo, doge (See Appendix~TODO for more background history).


\subsection{Memory}
After the system APIs have been initialized, we then initialized and allocated our system memory. We did this before any of our other code runs because the OS itself only contained pointers to our data structures. Since our data structures were allocated at this stage, any references to these structures would either hard fault or experience non-deterministic behaviour. The entire memory map of our system after initialization is shown on Figure~\ref{fig:memory-map}. 

\subsubsection{Kernel Memory Space}

After the process image, we dynamically allocated space for all of our kernel's data structures. We chose to allocate our data structures dynamically instead of at compile time because we were first "zeroing" out our entire memory space from \texttt{0x10008000} down to the end of our image with \texttt{0xDEADBEEF}. This made it easier to debug faults because if any registers (especially the link register) is \texttt{0xDEADBEEF} instead of 0 or some other random value, then we would instantly know that it was caused by uninitialized memory. In our kernel space, we initialized the following data structures:

\begin{itemize}
	\item \textbf{5 Ready, 5 memory blocked, and 5 message blocked queues:} 
	
	We had three states (ready, memory blocked, and message blocked) that each needed five queues, one for each priority. In total, we had 15 queues, each implemented as a doubly-linked list:
	\begin{code}
linkedlist_t
    node_t* first;
    node_t* last;
    int length;
	\end{code}
	
	\item \textbf{16 PCB Nodes:} (one for each PCB)
	
	Unlike a traditional linked list implementation, our linked list did not dynamically allocate and free memory. Instead, our implementation simply changed the pointers because we did not want our kernel to be blocked on memory or get pre-empted while it is running the scheduler. We wrapped our PCB struct with this node, instead of putting the next and previous pointers inside the PCB itself, was because we wanted the linked list implementation to be generic enough for other kernel features (such as the message queues).
	\begin{code}
node_t
    node_t* next;
    node_t* prev;
    void* value;
	\end{code}
	
	\item \textbf{16 PCBs:} (one for each process)
	
	Our PCBs themselves contain all of the information that the kernel needs to know about a process.
	\begin{code}
pcb_t
    uint32_t pid;
    PROCESS_STATE state;
    uint32_t priority;
    uint32_t* stack_ptr;
    linkedlist_t msg_queue;
	\end{code}
	
	The \texttt{PROCESS\_STATE} type is a enum that we use to keep track of the current state. Currently we have 6 states: new, ready, running, memory blocked, message blocked, and exit. 
	
\end{itemize}

\subsubsection{User Memory Space}
After we finished initializing our kernel's memory space, we then used the space above the PCBs for our memory blocks. However, before we initialized the memory blocks, we first byte aligned our heap pointer after the PCBs with \texttt{0x100}. This made it easier to debug with the memory window at the cost of at most 0xFF memory.

The memory blocks themselves have the same "header" as a regular node because we can then cast the memory blocks to nodes and reuse our linked list implementation. See Section~TODO for more details about the memory blocks.
\begin{code}
mem_blk_t
    mem_blk_t* next;
    mem_blk_t* prev;
    void* data;
    uint32_t padding;
\end{code}

\begin{figure}
\centering
\label{fig:memory-map}
\caption{Memory Map after Initialization}

\begin{bytefield}{}
    \begin{rightwordgroup}{User Memory Space}
    	\memsection{1000 7fff}{1000 6000}{10}{16 Process Stacks \\ (each size 0x200)} \\
    	\memsection{}{}{5}{-- unused --} \\
    	\memsection{}{}{10}{48 Memory Blocks \\ (each size 0x100)}
    \end{rightwordgroup} \\
    \begin{rightwordgroup}{Kernel Memory Space}
        \memsection{}{}{2}{16 PCBs} \\
        \memsection{}{}{2}{16 PCB Nodes} \\
        \memsection{}{}{2}{5 Message Blocked Queues} \\
        \memsection{}{}{2}{5 Memory Blocked Queues} \\
        \memsection{}{}{2}{5 Ready Queues} 
    \end{rightwordgroup}\\
    \memsection{}{}{2}{-- 8-byte Guard --} \\
    \memsection{End of Image}{1000 0000}{5}{Process Image} \\
\end{bytefield}

\end{figure}

\subsection{Processes}
After the memory had been allocated, we then move on to initializing our PCBs with their corresponding process information.

\subsubsection{Process tables}

First we call these methods to fill in our process tables:
\begin{code}
set_test_procs() // sets test processes 1-6
set_user_procs() // sets stress tests A-C, wall clock, and change priority
k_set_procs() // sets the null process, KCD, CRT, and i-processes
\end{code}

These methods filled in our process tables (which had been allocated at compile time instead of at runtime in the previous step):
\begin{code}
proc_image_t k_proc_table[NUM_K_PROCESSES] // size 5 (processes 0, 12-15)
proc_image_t g_test_procs[NUM_TEST_PROCESSES] // size 6 (processes 1-6)
proc_image_t u_proc_table[NUM_USER_PROCESSES] // size 5 (processes 7-11)
\end{code}

And each entry of our process table contained:
\begin{code}
proc_image_t
    uint32_t pid
    PROCESS_PRIORITY priority
    func_ptr_t proc_start
\end{code}

The \texttt{PROCESS\_PRIORITY} type is a enum that we use to designate the priority of a process from \texttt{HIGHEST} being 0 to \texttt{LOWEST} being 4. The \texttt{func\_ptr\_t} type is function pointer that points to where our process actually resides in memory. 

\subsubsection{Putting processes onto the ready queue}

After our process tables were filled, we then iterated over all the processes in the process tables and setup our PCBs:
\begin{enumerate}
	\item
	Copy the \texttt{pid} and \texttt{priority} into their corresponding PCBs.

	\item
	Set the PCB state to \texttt{NEW}.

	\item
	Initialize the PCB's message queue to be an empty linked list. Since the linked list was not declared as a pointer, its members (\texttt{first}, \texttt{last}, \texttt{length}) were already within the PCB struct.
	
	\item
	Assign a stack of size \texttt{0x200} from the top of the RAM (at \texttt{0x1000 8000}) or just below the previously allocated stack to the current process. The \texttt{stack\_ptr} in PCB itself, however, points 8 words below the start of the stack to allow the scheduler to work properly.
	
	 As specified in the board's documentation, to go from handler mode (scheduler) to thread mode (a user process), we need to use the \texttt{BL 0xFFFF FFF9} instruction. This special instruction pops values off the stack frame, as shown below, and copies them into their corresponding registers.
	
%	\begin{figure}[H] \label{fig:stack-after-branch}
%	\caption{Stack after calling \texttt{BL 0xFFFF FFF9}}
%	\begin{bytefield}[rightcurly=.]{L}
%		\begin{rightwordgroup}{$\leftarrow$ SP is here after resuming to thread mode}
%	   		\memsection{}{}{1.5}{-- NULL --} 
%		\end{rightwordgroup} \\
%	    \memsection{}{}{1.5}{xPSR = \texttt{0x1000 0000}} \\
%		\memsection{}{}{1.5}{PC = \texttt{proc\_start}} \\
%        \memsection{}{}{1.5}{LR = \texttt{0x0}} \\
%        \memsection{}{}{1.5}{R12 = \texttt{0x0}} \\
%        \memsection{}{}{1.5}{R3 = \texttt{0x0}} \\
%        \memsection{}{}{1.5}{R2 = \texttt{0x0}} \\
%        \memsection{}{}{1.5}{R1 = \texttt{0x0}} \\
%		\begin{rightwordgroup}{$\leftarrow$ SP initially points here in handler mode}
%		    \memsection{}{}{1.5}{R0 = \texttt{0x0}}
%		\end{rightwordgroup} \\
%	\end{bytefield}
%	\end{figure}
	
	Normally, these values are be automatically set when we make a system call from thread mode. However because our OS is initialized in handler mode, we need to manually set these default values (as shown above) the first time so that the scheduler don't hard fault. 
	
	Also, although the i-processes did not actually need a stack because they used the kernel stack whenever they got invoked, it made initialization a lot easier because our loop did not need to check process types. In addition, it was also at no cost to us because we still had leftover free space in our RAM in the end. 
	
\end{enumerate}

\section{Testing}\label{sec:test}

\section{Major Design Challenges}\label{sec:design}

\section{Timing Analysis}\label{sec:time}

\end{document}
