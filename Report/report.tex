% uw-wkrpt-se.tex - An example work report that uses uw-wkrpt.cls
% Copyright (C) 2002,2003  Simon Law
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We begin by calling the workreport class which includes all the
% definitions for the macros we will use.
\documentclass[se]{uw-wkrpt}

% LaTeX preamble: load some packages to add functionality
\usepackage{graphicx} % Include graphic importing

\usepackage[T1]{fontenc} % Better fonts
\usepackage{ae,aecompl}

\usepackage{indentfirst} % Indent first paragraph of each section

\usepackage[titletoc,title]{appendix} % Prefix appendix letters with `Appendix'

\usepackage{amsmath}
%\usepackage{scrextend}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{tkz-graph}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{bytefield}
\usepackage{listings,color}
\usepackage{float}


% Use the algorithmicx package for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}

% Use biblatex for references
\usepackage[style=ieee,sorting=none,dateabbrev=false,backend=biber]{biblatex}
\addbibresource{uw-wkrpt-bib.bib} % Specify the bibliography file

% This needs to be the last package loaded
\usepackage[pdftex]{hyperref} % Generate PDF links and bookmarks.
\hypersetup{
  bookmarks=true,
  bookmarksnumbered=true
}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{code}{%
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

% http://www.martin-demling.de/2011/06/memory-maps-in-latex-using-the-bytefield-package/
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip} % define the height of the memsection
	\bitbox[]{10}{
		\texttt{#1} % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{#2} % print start address
	}
	\bitbox{16}{#4} % print box with caption
}


% Now we will begin writing the document.
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IMPORTANT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% First we, should create a title page.  This is done below:
% Fill in the title of your report.
\title{OS WOW RTX Documentation}

% Fill in your name.
\author{Fasih Awan, Joshua Kalpin, Si Chuang Li, John Zanutto}

% Fill in your student ID number.
\uwid{20414848, 20414492, 20413578, TODO}

% Fill in the name of the PNG file with your signature, or leave unchanged.
\signature{signature}

% Fill in your home address.
\address{123 University Ave. W.\\*
         Waterloo, ON\ \ N2L 3G1}

% Fill in your employer's name.
\employer{SE 350}

% Fill in your employer's city and province.
\employeraddress{Thomas Reidemeister}

% Fill in your school's name.
\school{University of Waterloo}

% Fill in your faculty name.
\faculty{Software Engineering}

% Fill in your student user ID
\userid{fawan, jkalpin, sc6li, jzanutto}

% Fill in your e-mail address.
\email{jrhacker@engmail}

% Fill in your term.
\term{3A}

% Fill in your program.
\program{Software Engineering}

% Fill in the department chair's name.
\chair{Dr.\ A.\ Morton}

% Fill in the department chair's mailing address.
\chairaddress{Software Engineering\\*
              University of Waterloo\\*
	      Waterloo, ON\ \ N2L 3G1}

% If you are writing an "SE-confidential" report, uncomment the next line.
%\confidential{SE-confidential}

% If you want to specify the date, fill it in here.  If you comment out
% this line, today's date will be substituted.
%\date{April 24, 2012}

% Now, we ask LaTeX to generate the title.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \frontmatter will make the \section commands ignore their numbering,
%% it will also use roman page numbers.
\frontmatter

% Next, we need to make a Table of Contents, List of Figures and 
% List of Tables.  You will most likely need to run LaTeX twice to
% get these correct.  The first pass for LaTeX to figure out the
% labels, and the second pass to put in the right references.

\setcounter{tocdepth}{1}

\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REPORT BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \main will make the \section commands numbered again,
%% it will also use arabic page numbers.
\mainmatter

% You must have an Introduction
\section{Introduction}\label{sec:intro}

\subsection{About}

This report is a detailed design document describing the OS WOW Real-Time Operation System designed by Fasih Awan, Joshua Kalpin, John Zanutto and Si Chuang Li. This operating system was implemented for the Keil MCB1700 board populated with an NXP LPC1768 microcontroller. 

This operating system was created over the span of three months during the creator's 3A term in Software Engineering. It was developed in four parts adding more features each time. The first part involved creating basic memory management and process handling. The second part added the challenge of interrupts and a console. The third part added more processes. Lastly, the fourth part of the project included timing tests and this report.

\subsection{Purpose}

The purpose of this report is to provide the reader with detailed documentation on the OS WOW operating system. This includes the following information. First, the data structures and global variables that the kernel uses. Second, this report will document the APIs that are available to users of the operation system. Third, details on how interrupts are handled within the operating system will be specified. Fourth, the various system, user and test processes will be explained. Fifth, details on how the operating system is initialized, including memory and processes will be provided. Lastly, there will be details on testing, design challenges and timing analysis on the functions of the operating system.

\section{Global Variables}\label{sec:global}

\subsection{Linked Lists}

\subsection{Memory}

\subsection{Processes}

\subsection{Timers}

\subsection{Inter-Process Communication}

\section{Kernel API} \label{sec:kernel}

\subsection{Memory}

The kernel keeps track of the available memory with a global pointer \texttt{free\_mem} that points to the first block of the list of free memory blocks. Whenever a memory block is requested, the front of this list is removed (if the list is not empty) and is given to the requester. Whenever a memory block is released, the given block is added to the front of this list.

\subsubsection{Request Memory}
\begin{code}
void* request_memory_block()
\end{code}

This method takes zero arguments and returns an address to a piece of memory that the caller can use. The returned address points to a continuous block of memory of size \texttt{0x1E4} bytes that the current process can read and write to. Currently, the memory protection unit is disabled so if the process reads or writes outside of \texttt{returned address + 0x1E4}, then undefined behaviour will occur.

If the system is out of memory, then the calling process will be pre-empted and will be placed on its priority's memory blocked queue until more memory becomes available (i.e. when another process releases their memory). It is recommended that once the user is finished with their allocated block that they release it otherwise the system will run out of memory very quickly.

\subsubsection{Release Memory}
\label{sec:release-memory-block}
\begin{code}
int32_t release_memory_block(void*)
\end{code}

This method takes in a pointer returned by \texttt{request\_memory\_block()}, deallocates it, and returns 0 if successful. If there was an error or if the pointer was invalid such as NULL or out of the range of the RAM, this method returns -1. This method also checks if there are currently any processes blocked on memory with a priority greater than or equal to the calling process. If so, then the current process will get pre-empted and the scheduler will get called instead of continuing with the current process.

\subsubsection{Example Usage of Requesting and Releasing Memory}
\begin{code}
void example_process(void) {
    int* array;
    
    while (1) {
        array = (int*) request_memory_block();
        array[0] = 0xDEADC0DE;
        release_memory_block(array);
    }
}
\end{code}

\subsection{Process Management}

There are three functions available to processes for managing scheduling and the processor. These functions can be called by including the \texttt{process.h} header file and are specified below.

\subsubsection{Releasing the Processor}

\subsubsection{Changing a Process' Priority}

\subsubsection{Getting a Process' Priority}

\subsection{Inter-Process Communcation} \label{sec:ipc}

Inter-Process Communication is managed by using a messaging passing system within the operating system. Messages are handled in two parts, kernel and user messages. User messages contain two properties, the message type and the message data itself. Kernel messages contain other information such as the sender of the message, the receiver of the message, a linked list node for storing the message and its expiry time.

\begin{code}
//A kernel message
typedef struct {
    node_t msg_node;
    uint32_t sender_pid;
    uint32_t receiver_pid;
    uint32_t expiry;
    
    //user message parameters
    uint32_t msg_type;
    char msg_data[1];
} message_t;
\end{code}

\subsubsection{Send Message}

\begin{code}
int32_t send_message(int32_t process_id, void* message_envelope)
\end{code}

The \texttt{send\_message} takes in two parameters, a process id and a message envelope and will return 0 on success. The process id must be a valid process inside of the operating system otherwise the function will return 1. The message envelope to be sent must be created by the calling process. First, the process must request a memory block and cast it to be of type \texttt{msg\_buf\_t}. Then, the process can specify a type and message data to be sent.

Once a process sends a message, the kernel will then convert the message to be a kernel message. This is done by subtracting a offset equal to the size of the kernel header from the struct to reveal the user hidden properties. After doing this, the message is initialized with the sender process id, receiver process id and its linked list node is instantiated. The message is then added to the receiving process' message queue. If the receiving process was blocked on messages, it will then be added to its appriorite ready queue. Additionally, if the process is of equal or higher priority to the current process, the current process will be pre-empted.

\subsubsection{Receive Message}

\begin{code}
void* receive_message(int32_t* sender_id)
\end{code}

The receive message function takes in one parameter, a pointer to an integer and will return the received message. The integer pointer passed in will be used to store the the process id of the process that sent the message. 

Once a process wants to receive a message, its message queue is queried to see if there are any waiting messages. If there are no messages available, the process is marked as \texttt{MSG\_BLOCKED}, added to its appropriate message blocked queue and the processor is released. Once there is a message available, it is popped off the process' message queue. Then, if there was a non-null parameter passed in, it stores the process id of the sending process inside of that pointer. Lastly, the message is converted back into a user message and returned to the user.

\subsubsection{Delayed Send}

\section{Interrupts}\label{sec:interupt}

\subsection{Keyboard Interrupts}

\subsubsection{UART I-Process}

The keyboard interrupt process takes an input that a user enters via the keyboard, processes it, and outputs it. Depending on the type of input, the system will respond differently (in the case of commands and hotkeys).

Keyboard interrupts are handled by the UART i-process. When an interrupt is received interrupts are immediately disabled to prevent nested interrupts from occuring. 

\begin{code}
CPSID i                        ;disable interrupts
;handle interrupt
CPSIE i                         ;enable interrupts
\end{code}

After disabling interrupts, the UART i-process is immediately invoked. The UART i-process reads input into a buffer and outputs each character as it is typed to the console allow the user to see their input. Once a carriage return (\texttt{\\r}) is received, buffer writing is postponed and the input will be processed. A special set of functions are invoked (post-fixed with \texttt{\_i} to allow this i-process to send messages without blocking or pre-emption. If it cannot obtain a memory block, the buffer is discarded. If it can obtain a memory block, the buffer is copied into a message envelope and sent to the KCD for decoding. 

This i-process will also check to see if it has any pending messages. This receive message call is non-blocking and will continue execution if no message is received. If a message is received, the message is printed using the UART output buffer. The i-process cannot be blocked because it is not scheduled regularly, so any regular system functions have modified versions designed to run specifically for the i-process.

\subsubsection{Debug Hotkeys}

Debugging hotkeys were designed to make debugging easier by outputting useful debug information when a key is pressed. As such, they were designed to work without memory. A last check is performed in the keyboard i-process to determine if a hotkey is used. There are currently three implemented debug hotkeys. Each of these hotkeys produces a separate output in the UART-1 system console. The hotkeys will produce output when the flag \_DEBUG\_HOTKEYS is enabled. 

The three hotkeys are as follows. If the "," key is pressed, the processes currently in the ready state are printed out. If the "/" key is pressed, processes that are messaged blocked are printed out. If the "." key is pressed, processes that are memory blocked are printed out.

\subsection{Timer Interrupts}

The timer interrupt is an interrupt that happens every millisecond. This interrupt first disables any other interrupts from starting, so the OS does not call another timer interrupt while within a timer interrupt, and then goes to the interrupt handler. The interrupt handler first increments a global variable named \texttt{g\_timer\_count} which is just a timing variable. The interrupt handler then calls the timer interrupt process \texttt{timer\_i\_process}. 

The \texttt{timer\_i\_process} first gets the pointer to the front of its message queue, where delayed messages get sent, and then continues to check the front of the queue for any messages who have an expiry date that is less than the current timer count. If the expiry value for the message is less than the current timer count, then it is dispatched using \texttt{send\_message}. Once it hits a message at the front of the queue who's expiry date is greater than the current timer count, the process stops iterating the front of the queue and exits. Once the process exits, the interrupt handler enables interrupts, and exits.


\section{System and User Processes}\label{sec:proc}

\subsection{System Processes}

There are three system processes, the Null Process, the CRT Display, and the Keyboard Command Decoder.

\subsubsection{Null Process}

The Null Process runs as an infinite loop of releasing the processor. This process will only execute if all other processes are blocked, or there are no other processes in the system. As a result, this process has a special reserved priority that is the lowest possible in the system. Pseudocode for this process is below.

\begin{code}
while looping forever do
    release the processor
end
\end{code}

\subsubsection{Keyboard Command Decoder}

The Keyboard Command Decode (KCD) is designed to handle both the registration and the parsing of commands from the keyboard. The KCD takes all input in the form of a message from the UART i-process, determines which process corresponds to that command, and sends the command in a message to that process. The initial KCD state will be memory blocked upon first executing. The KCD parses input based on two types of messages, \texttt{DEFAULT} and \texttt{KCD\_REG}.

Default messages are treated as inputted commands, and are parsed by checking to see whether the command registered is contained in the contents of the message. If a command is found in the buffer (denoted by a \% symbol), it is checked against a list of registered commands. Commands are stored and implemented as an array of command structs (see below).
\begin{code}
typedef struct {
    uint32_t pid;
    char cmd[10];
} kcd_cmd_t;
\end{code}

When a command is discovered, it is compared against a command in the list of commands. The operating system assumes that all commands will be at most ten characters, and there will be no more than ten commands registered at any given time. The buffer is then copied into a new message envelope and sent to the process ID of the process that registered the matching command.

KCD registration messages are registered into the command list, along with the sender of the message and the type of command. The message is then released here. Registration with the KCD is done by sending a message of type \texttt{KCD\_REG} to the process with the specific command as the message data. This is then stored into the command list for future use and the memory allocated for the message is released.


\subsubsection{CRT Display}

The CRT Display process is a controller that provides a level of abstraction between the interrupt process and any user process trying to output. This mainly applies to processes that accept command input, such as the wall clock and the priority change process. 

The CRT receives a message and checks if it is of type \texttt{CRT\_DISPLAY}. If it is a valid message, it sends the message to the UART i-process(Section~\ref{sec:interupt}) and triggers a keyboard interrupt to check for messages and perform the print operation. Otherwise, it will release the memory block.

\subsection{User Processes}

These processes can be found inside of \texttt{user\_proc.c}. These processes require registration of commands with the KCD, and only function on user input.

\subsubsection{Wall Clock}

The wall clock displays the time specified by the user in the HH:MM:SS format (hours, minutes, seconds). The user can set the time themselves, let the clock run from 00:00:00 upwards or terminate the clock.

The wall clock process first registers \texttt{\%W} command with the CRT. It then attempts to receive a message. The wall clock uses a state variable to determine whether the clock is currently running or not.

If the clock is running and the message received was sent by the clock itself, \texttt{delayed\_send} is used to send another message, with a 1 second delay, to itself. The message sent by \texttt{delayed\_send} is of the \texttt{DEFAULT} message type. The process then requests another memory block and sends a message of type \texttt{CRT\_DISPLAY} to the CRT containing the updated time.

If the clock is not running, or the message was not sent by the clock, it is validated against the registered command. If the command is valid, it is parsed for the correct information.

The \texttt{\%WR} command resets the clock. Specifically, it will set the current time to be zero, and begin running the clock. If the clock is just starting, a \texttt{CRT\_DISPLAY} message is sent to the CRT immediately to display the initial time 00:00:00. The process then proceeds to send delayed messages to itself. An error will be thrown is the input provided is not exactly \texttt{\%WR}.

The clock set command, \texttt{\%WS},  requires significant validation for the input. The colon locations, the spaces and all of the values are verified to determine whether the input is correct. An error will not be thrown if the input is not specified in the below format.
\begin{code}
\%WS HH:MM:SS
\end{code}

\texttt{H} represents hours, \texttt{M} represents minutes and \texttt{S} represents seconds. Each of these is required to be specified as two digits (e.g. 01:01:01). If the input matches this format, the clock is updated with the correct time, and a \texttt{CRT\_DISPLAY} message is sent to the CRT to display the new time immediately. The clock is then set to running if it is not currently running, and will begin sending delayed messages to itself.

The \texttt{\%WT} command terminates the clock if it is currently running. Otherwise, nothing happens. An error will be thrown if the input is not exactly \texttt{\%WT}.

Additionally, when the clock outputs, the output is sent to the top right corner of the terminal. This was done with by using special parsing modifiers in the output string. This can be seen below.
\begin{code}
"\033[s\033[1;69H\%02d:\%02d:\%02d\n\033[u"
\end{code}


\subsubsection{Change Process Priority}

The change priority process takes a user input command and sets the priority of a specified process to a specified priority when both are valid input. This process functions with the below input into the console by the user.

\begin{code}
\%C [Process ID] [New Priority]
\end{code}

\texttt{Process ID} is the id of the process that will be changed, and ranges from process id 1 to process id 13. This id range excludes the i-processes and the Null Process and they have fixed priorities.

\texttt{New Priority} is the priority that the process will receive. This excludes priority 4 (denoted LOWEST in the priority enumerable) as that priority is reserved for the Null Process.

The change priority process first registers the \texttt{\%C} command with the KCD. It then will wait until it receives a message from the KCD.

The process does several error checks for validation. These include checking for invalid priorities, invalid process ids, process ids that are not numbers and priorities that are not numbers. Checking for valid command format is also done here (i.e. if spaces are used correctly). If the input is invalid, an error message is sent to the CRT for display. Otherwise, the \texttt{set\_process\_priority} method is called with the parsed process id and new priority. This process also outputs all input information to the debug window.

\subsubsection{Stress Test A}

The first stress test user process starts off by creating a new message and sending it to the KCD. The message itself is the string text \texttt{\%Z}, which is a command accepted by the KCD. After the message has been send, the process goes on a continuous loop where it calls \texttt{receive\_message}, which will block the process until it receives the message being sent to it. After the message has been received, the process exits the continuous loop, and enters another loop.

The second loop first calls \texttt{request\_memory\_block} to allocate memory for the message envelope. After receiving memory, it prepares the message block by assigning the message type to be \texttt{COUNT\_REPORT} which will allow the target process to continue its tasks. The sender of the message is set to the second user stress test process.


\subsubsection{Stress Test B}

This stress test process simply runs in a continuous loop and calls \texttt{receive\_message}. While it calls that function, it will become blocked until the message being sent to this process is received. Once received, this process relays that message by sending it to the third stress test process, process C.


\subsubsection{Stress Test C}

This process receives the messages which were created and sent in stress test A and then relayed by stress test B. This process starts out by creating a circular buffer \texttt{message\_queue} which acts as a message queue. The message queue will hold all the messages that this process receives.

Once the message queue has been initialized, the process enters a loop. First it checks if the message queue is empty, and if it is then the process calls \texttt{receive\_message} and remains blocked while waiting for a message to be sent to it. If the message queue was not empty, then a message is popped off from the from of the queue, and the queues front pointers are updated to the next element.

The process now checks the message type that it either received of popped off from the queue. In stress test A the message type was set to \texttt{COUNT\_REPORT}, which is what this process will now check for. If the message type is not \texttt{COUNT\_REPORT} then the process releases the memory block allocated, and then calls \texttt{release\_processor}. Then it reiterates from the beginning.

If the message type is \texttt{COUNT\_REPORT}, then the process checks if the value contained in the message is divisible by 20. If not, it releases the memory block for the message envelope, releases the process, and then reiterates. If the value is in fact divisible by 20, the process sends the message received to the CRT Display. Once sent, it creates a new message with a message type of \texttt{WAKEUP10} and sends it to itself using a delayed send with a delay of 10 seconds. The process now waits for the message it sent to itself. It will call \texttt{receive\_message} continuously. If the message type is not \texttt{WAKEUP10} then it pushes the message to the end of the message queue. If the message type is \texttt{WAKEUP10}, it restarts the loop.

\subsubsection{Stress Test User Process C Flow}
\begin{code}
while (1)
	if (queue is not empty)
		envelope = receive_message()
	else
		envelope = queue.pop_front
	if (envelope.type == COUNT_REPORT)
		if (envelope.data % 20 == 0)
			send_message(CRT_DISPLAY, envelope)
			envelope.type = WAKEUP10
			delayed_send(envelope, 10 seconds)
			while (1)
				envelope = receive_message()
				if (envelope.type == WAKEUP10)
					break
				else
					queue.push_back(envelope)
\end{code}


\section{Test Processes}\label{sec:testproc}

Overall there are 6 test process. The first five test processes test the functionality of the OS, and the sixth test polls all the results. In order to do that, an array of integers is defined which is used to set the result of the test as a $1$ or a $0$. All the test processes start off with a process priority of \texttt{MEDIUM}, and the polling process starts off with a priority of \texttt{LOW}. 


\subsection{Process 1}

The first test process tests the delayed send functionality. It creates a message with a specific text and sends it to itself with a delay of 1 \texttt{CLOCK\_INTERVAL} which is defined as $1000$ milliseconds. Then it calls \texttt{receive\_message} and blocks itself until it receives the message. The process then checks if the message text matches what was sent off using \texttt{strcmp}. It then sets its own priority to \texttt{LOW} and enters an infinite loop of calling \texttt{release\_processor}. 


\subsection{Process 2}

The second test process tests sending messages. It creates a new message with a specified string, and sends it to the third test process. The process then calls \texttt{receive\_message} and blocks itself until a message gets sent to it. Once the process receives its message, which the third process will be sending it, it compares the string text to make sure it matches the expected string, and then sets its own priority to \texttt{LOW}. It then enters an infinite loop of calling \texttt{release\_processor}. 


\subsection{Process 3}

The third test process also tests sending messages. It creates a new message with the string that the second test process is expecting, and then send it off using \texttt{send\_message}. It then calls \texttt{receive\_message} waiting for the message that was sent to it to come in. The process is blocked until then. Once it receives the message, it compares the string to the expected string, sets its own priority to \texttt{LOW} and then enters an infinite loop of calling \texttt{release\_processor}.


\subsection{Process 4 & Process 5}

The fourth test process and the fifth test processes are similar processes. These processes test preemption based on process priority. They both have internal counters that are incremented. Both processes increment their counter every time the loop iterates twice. In the fourth test process when the counter hits 5, it sets the process priority of the fifth test process to \texttt{HIGH} and exits the first loop. It then checks if the fifth process finished first or not. In the fifth test process, when the counter hits 10 it sets the process priority of the fourth process to \texttt{HIGH}. The expected result is that the fourth process will finish first, and the fifth one finishes second. To check that, the process checks the numerical array created to see if the fifth test already completed. 


\subsection{Process 6}

The last test process just polls the result from the numerical arrays to see if they passed or failed, and then just outputs the results as $x/5\ \text{PASSED}$ and $y/5\ \text{FAILED}$. If any of the processes have not fully run yet, by checking if the test run array has a $0$ for their entry, then the process will run an infinite loop calling \texttt{release\_processor} until all other processes have ran. Once all of them have ran, it prints out the final results, and then goes into an infinite loop of calling \texttt{release\_processor}.

\section{Initialization}\label{sec:init}

At the start of the OS, the OS disables interrupts before it initializes the system, otherwise the interrupt handlers cannot run properly. Once everything is initialized properly, it re-enables interrupts and calls the scheduler to dispatch the first process.

\subsection{System APIs}
The first stage of the initialization is to setup the system APIs. First, \texttt{SystemInit()} ic alled to setup the board and the system clock frequency. Second, \texttt{init\_printf(NULL, putc)} is called to enable the use of \texttt{printf} for debugging. Third, \texttt{uart\_irq\_init(0)} enables interrupt-driven I/O on UART0. Fourth, \texttt{uart1\_init()} enables program-driven I/O on UART1 for debugging. Fifth, \texttt{timer\_init(0)} enables the first timer for sending delayed messages. Sixth,  \texttt{timer\_init(1)} enables the second timer for benchmarking. Lastly, \texttt{init\_logo\_on\_lcd()} enables the ability to draw our OS's logo on the LCD display.

\subsection{Memory}

\begin{figure}[h] \label{fig:memory-map}
\caption{Memory Map after Initialization}
\begin{bytefield}{}
    \begin{rightwordgroup}{User Memory Space}
    	\memsection{0x1000 7fff}{0x1000 6000}{4}{16 Process Stacks \\ (each size 0x200)} \\
    	\memsection{}{}{1.5}{-- unused --} \\
    	\memsection{}{}{3}{48 Memory Blocks \\ (each size 0x100)}
    \end{rightwordgroup} \\
    \memsection{0x100 aligned}{}{1.5}{-- unused --} \\
    \begin{rightwordgroup}{Kernel Memory Space}
        \memsection{}{}{1.5}{16 PCBs} \\
        \memsection{}{}{1.5}{16 PCB Nodes} \\
        \memsection{}{}{1.5}{5 Message Blocked Queues} \\
        \memsection{}{}{1.5}{5 Memory Blocked Queues} \\
        \memsection{}{}{1.5}{5 Ready Queues} 
    \end{rightwordgroup}\\
    \memsection{}{}{1.5}{-- 2 word(8 byte) guard --} \\
    \memsection{End of Image}{1000 0000}{3}{Process Image} \\
\end{bytefield}
\end{figure}

After the system APIs have been initialized, the OS then zeros out all of the memory from the end of the system image to the end of RAM with \texttt{0xDEADBEEF}. This makes it easier to debug because if a value after this stage is \texttt{0xDEADBEEF}, then it will be obvious that the value was not properly instantiated. After zeroing out the memory, the OS then dynamically allocates memory for its data structures.  A map of the system memory after initialization is shown on Figure~\ref{fig:memory-map}.

\subsubsection{Kernel Memory Space}

After the process image, the OS dynamically allocates space for all of its kernel's data structures. It first allocates 15 doubly-linked lists to represent 5 ready queues, 5 memory blocked queues, and 5 message blocked queues, one for each process priority. Unlike a traditional linked list implementation, the OS's linked lists do not dynamically allocate and free memory. Instead, the OS simply changes the node pointers because the kernel should never be blocked on memory or get pre-empted while it is running the scheduler. As a result, the OS's PCBs are wrapped with linked list nodes that are preallocated during its initialization stage. In total, the OS allocates 16 PCBs and 16 nodes structures for managing the PCBs.

\subsubsection{User Memory Space}
After the kernel's data structures have been instantiated, the OS then use the space above the PCBs for memory blocks. It first byte aligns the first memory block after the PCBs with \texttt{0x100}. This makes it easier to debug at the cost of at most \texttt{0xFF} memory. From the \texttt{0x100} byte-aligned address, the OS instantiates 48 new \texttt{0x200} doubly linked blocks as shown below (i.e. each block has a pointer to its subsequently and previously instantiated blocks).

\begin{figure}[h] \label{fig:memory-block}
\caption{Memory Block}
\begin{bytefield}{}
    \memsection{0x200}{}{1.5}{\texttt{next}} \\
    \memsection{}{}{1.5}{\texttt{prev}} \\
    \begin{rightwordgroup}{Message Header}
    	\memsection{}{}{6}{-- 4 words (16 bytes) --}
    \end{rightwordgroup} \\
    \begin{rightwordgroup}{User space of size \texttt{0x1E4}}
    	\memsection{0x1E8}{0x4}{8}{\texttt{data}}
    \end{rightwordgroup} \\
    \memsection{}{}{1.5}{\texttt{padding = 0xABAD1DEA}} 
\end{bytefield}
\end{figure}

As shown in Figure~\ref{fig:memory-block}, each memory block is instantiated to be size \texttt{0x200}. However, the OS needs to reserve the top 6 words (24 bytes) for memory and message management (See Section~\ref{sec:ipc} for more information about messages). In addition, the OS reserves the bottom word (4 bytes) as a safety padding to help with debugging. This padding is required because it can detect if a user process writes past their allowable region by verifying the values in the padding. 

Finally, after all of these blocks are initialized, the OS sets the global \texttt{free\_mem} variable to point to the first memory block of this list. 

\subsection{Processes}
After both the kernel and user memory space have been initialized, the OS then moves on to initializing its PCBs with their corresponding process information. First the OS calls the processes' provided initialization methods (e.g. \texttt{set\_test\_procs()}) to fill in its process tables, \texttt{g\_test\_procs}. Each entry of the completed process table contains the corresponding process's pid, priority, and pointer to where the process actually resides in memory. 

After the process tables are filled, the OS then iterates over all the processes in the process tables and initializes its PCBs in a number of steps. First, the \texttt{pid} and \texttt{priority} values are copied into the PCB. Second, the PCB state is set to \texttt{NEW}. Third, the PCB's message queue is initialized to be an empty linked list. Fourth, it initializes the process's stack (see Section~\ref{sec:setting-up-stack}). Lastly, it sets \texttt{stack\_ptr} to the appropriate location.
	
Although the i-processes do not need a stack because they rely on the kernel's stack whenever they run, it makes initialization simpler because the loop does not need to check process types. In addition, it was also of no consequence because there is still leftover space between the stacks and memory blocks.

\subsubsection{Setting up the Stack} \label{sec:setting-up-stack}

As specified in the board's documentation, to go from handler mode to thread mode, the OS uses the \texttt{BL 0xFFFF FFF9} instruction. This special instruction pops values off the stack frame, as shown in Figure~\ref{fig:stack-after-branch}, and copies them into their corresponding registers.
	
\begin{figure} \label{fig:stack-after-branch}
\caption{Stack after calling \texttt{BL 0xFFFF FFF9}}
\begin{bytefield}[rightcurly=.]{}
	\begin{rightwordgroup}{$\leftarrow$ SP is here after resuming to thread mode}
		\memsection{}{}{1.5}{-- NULL --} 
	\end{rightwordgroup} \\
	\memsection{}{}{1.5}{xPSR = \texttt{0x1000 0000}} \\
	\memsection{}{}{1.5}{PC = \texttt{proc\_start}} \\
    \memsection{}{}{1.5}{LR = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R12 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R3 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R2 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R1 = \texttt{0x0}} \\
	\begin{rightwordgroup}{$\leftarrow$ SP initially points here in handler mode}
		\memsection{}{}{1.5}{R0 = \texttt{0x0}}
	\end{rightwordgroup} \\
\end{bytefield}
\end{figure}
	
Normally, these values are automatically set when the user makes a system call from thread mode. However because the OS is initialized in handler mode, it needs to manually set default values the first time it runs so that the scheduler does not hard fault. In other words, the OS writes the default values to the stack as show in Figure~\ref{fig:stack-after-branch} and sets \texttt{stack\_ptr} to point 8 words below the start of the stack.

\section{Testing}\label{sec:test}

\subsection{Verification}

\subsection{Debugging}

\section{Major Design Challenges}\label{sec:design}

\subsection{Mistakes}

\subsection{Stumbling Blocks}

\subsection{Things To Change}

\subsection{Design Issues}

\subsection{Group Challenges}

\section{Timing Analysis}\label{sec:time}

\end{document}
