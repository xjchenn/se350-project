% uw-wkrpt-se.tex - An example work report that uses uw-wkrpt.cls
% Copyright (C) 2002,2003  Simon Law
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We begin by calling the workreport class which includes all the
% definitions for the macros we will use.
\documentclass[se]{uw-wkrpt}

% LaTeX preamble: load some packages to add functionality
\usepackage{graphicx} % Include graphic importing

\usepackage[T1]{fontenc} % Better fonts
\usepackage{ae,aecompl}

\usepackage{indentfirst} % Indent first paragraph of each section

\usepackage[titletoc,title]{appendix} % Prefix appendix letters with `Appendix'

\usepackage{amsmath}
%\usepackage{scrextend}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{tkz-graph}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{bytefield}
\usepackage{listings,color}
\usepackage{float}


% Use the algorithmicx package for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}

% Use biblatex for references
\usepackage[style=ieee,sorting=none,dateabbrev=false,backend=biber]{biblatex}
\addbibresource{uw-wkrpt-bib.bib} % Specify the bibliography file

% This needs to be the last package loaded
\usepackage[pdftex]{hyperref} % Generate PDF links and bookmarks.
\hypersetup{
  bookmarks=true,
  bookmarksnumbered=true
}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{code}{%
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

% http://www.martin-demling.de/2011/06/memory-maps-in-latex-using-the-bytefield-package/
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip} % define the height of the memsection
	\bitbox[]{10}{
		\texttt{#1} % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{#2} % print start address
	}
	\bitbox{16}{#4} % print box with caption
}


% Now we will begin writing the document.
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IMPORTANT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% First we, should create a title page.  This is done below:
% Fill in the title of your report.
\title{OS WOW RTX Documentation}

% Fill in your name.
\author{Fasih Awan, Joshua Kalpin, Si Chuang Li, John Zanutto}

% Fill in your student ID number.
\uwid{20414848, 20414492, 20413578, TODO}

% Fill in the name of the PNG file with your signature, or leave unchanged.
\signature{signature}

% Fill in your home address.
\address{123 University Ave. W.\\*
         Waterloo, ON\ \ N2L 3G1}

% Fill in your employer's name.
\employer{SE 350}

% Fill in your employer's city and province.
\employeraddress{Thomas Reidemeister}

% Fill in your school's name.
\school{University of Waterloo}

% Fill in your faculty name.
\faculty{Software Engineering}

% Fill in your student user ID
\userid{fawan, jkalpin, sc6li, jzanutto}

% Fill in your e-mail address.
\email{jrhacker@engmail}

% Fill in your term.
\term{3A}

% Fill in your program.
\program{Software Engineering}

% Fill in the department chair's name.
\chair{Dr.\ A.\ Morton}

% Fill in the department chair's mailing address.
\chairaddress{Software Engineering\\*
              University of Waterloo\\*
	      Waterloo, ON\ \ N2L 3G1}

% If you are writing an "SE-confidential" report, uncomment the next line.
%\confidential{SE-confidential}

% If you want to specify the date, fill it in here.  If you comment out
% this line, today's date will be substituted.
%\date{April 24, 2012}

% Now, we ask LaTeX to generate the title.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \frontmatter will make the \section commands ignore their numbering,
%% it will also use roman page numbers.
\frontmatter

% Next, we need to make a Table of Contents, List of Figures and 
% List of Tables.  You will most likely need to run LaTeX twice to
% get these correct.  The first pass for LaTeX to figure out the
% labels, and the second pass to put in the right references.

\setcounter{tocdepth}{1}

\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REPORT BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \main will make the \section commands numbered again,
%% it will also use arabic page numbers.
\mainmatter

% You must have an Introduction
\section{Introduction}\label{sec:intro}

\subsection{About}

This report is a detailed design document describing the OS WOW Real-Time Operation System designed by Fasih Awan, Joshua Kalpin, John Zanutto and Si Chuang Li. This operating system was implemented for the Keil MCB1700 board populated with an NXP LPC1768 microcontroller. 

This operating system was created over the span of three months during the creator's 3A term in Software Engineering. It was developed in four parts adding more features each time. The first part involved creating basic memory management and process handling. The second part added the challenge of interrupts and a console. The third part added more processes. Lastly, the fourth part of the project included timing tests and this report.

\subsection{Purpose}

The purpose of this report is to provide the reader with detailed documentation on the OS WOW operating system. This includes the following information. First, the data structures and global variables that the kernel uses. Second, this report will document the APIs that are available to users of the operation system. Third, details on how interrupts are handled within the operating system will be specified. Fourth, the various system, user and test processes will be explained. Fifth, details on how the operating system is initialized, including memory and processes will be provided. Lastly, there will be details on testing, design challenges and timing analysis on the functions of the operating system.

\section{Global Variables}\label{sec:global}

\subsection{Linked Lists}

\subsection{Memory}

\subsection{Processes}

\subsection{Timers}

\subsection{Inter-Process Communication}

\section{Kernel API} \label{sec:kernel}

\subsection{Memory}

The kernel keeps track of the available memory with a global pointer \texttt{free\_mem} that points to the first block of the list of free memory blocks. Whenever a memory block is requested, the front of this list is removed (if the list is not empty) and is given to the requester. Whenever a memory block is released, the given block is added to the front of this list.

\subsubsection{Request Memory}
\begin{code}
void* request_memory_block()
\end{code}

This method takes zero arguments and returns an address to a piece of memory that the caller can use. The returned address points to a continuous block of memory of size \texttt{0x1E4} bytes that the current process can read and write to. Currently, the memory protection unit is disabled so if the process reads or writes outside of \texttt{returned address + 0x1E4}, then undefined behaviour will occur.

If the system is out of memory, then the calling process will be pre-empted and will be placed on its priority's memory blocked queue until more memory becomes available (i.e. when another process releases their memory). It is recommended that once the user is finished with their allocated block that they release it otherwise the system will run out of memory very quickly.

\subsubsection{Release Memory}
\label{sec:release-memory-block}
\begin{code}
int32_t release_memory_block(void*)
\end{code}

This method takes in a pointer returned by \texttt{request\_memory\_block()}, deallocates it, and returns 0 if successful. If there was an error or if the pointer was invalid such as NULL or out of the range of the RAM, this method returns -1. This method also checks if there are currently any processes blocked on memory with a priority greater than or equal to the calling process. If so, then the current process will get pre-empted and the scheduler will get called instead of continuing with the current process.

\subsubsection{Example Usage of Requesting and Releasing Memory}
\begin{code}
void example_process(void) {
    int* array;
    
    while (1) {
        array = (int*) request_memory_block();
        array[0] = 0xDEADC0DE;
        release_memory_block(array);
    }
}
\end{code}

\subsection{Process Management}

There are three functions available to processes for managing scheduling and the processor. These functions can be called by including the \texttt{process.h} header file and are specified below.

\subsubsection{Releasing the Processor}

\subsubsection{Changing a Process' Priority}

\subsubsection{Getting a Process' Priority}

\subsection{Inter-Process Communcation} \label{sec:ipc}

Inter-Process Communication is managed by using a messaging passing system within the operating system. Messages are handled in two parts, kernel and user messages. User messages contain two properties, the message type and the message data itself. Kernel messages contain other information such as the sender of the message, the receiver of the message, a linked list node for storing the message and its expiry time.

\begin{code}
//A kernel message
typedef struct {
    node_t msg_node;
    uint32_t sender_pid;
    uint32_t receiver_pid;
    uint32_t expiry;
    
    //user message parameters
    uint32_t msg_type;
    char msg_data[1];
} message_t;
\end{code}

\subsubsection{Send Message}

\begin{code}
int32_t send_message(int32_t process_id, void* message_envelope)
\end{code}

The \texttt{send\_message} takes in two parameters, a process id and a message envelope and will return 0 on success. The process id must be a valid process inside of the operating system otherwise the function will return 1. The message envelope to be sent must be created by the calling process. First, the process must request a memory block and cast it to be of type \texttt{msg\_buf\_t}. Then, the process can specify a type and message data to be sent.

Once a process sends a message, the kernel will then convert the message to be a kernel message. This is done by subtracting a offset equal to the size of the kernel header from the struct to reveal the user hidden properties. After doing this, the message is initialized with the sender process id, receiver process id and its linked list node is instantiated. The message is then added to the receiving process' message queue. If the receiving process was blocked on messages, it will then be added to its appriorite ready queue. Additionally, if the process is of equal or higher priority to the current process, the current process will be pre-empted.

\subsubsection{Receive Message}

\begin{code}
void* receive_message(int32_t* sender_id)
\end{code}

The receive message function takes in one parameter, a pointer to an integer and will return the received message. The integer pointer passed in will be used to store the the process id of the process that sent the message. 

Once a process wants to receive a message, its message queue is queried to see if there are any waiting messages. If there are no messages available, the process is marked as \texttt{MSG\_BLOCKED}, added to its appropriate message blocked queue and the processor is released. Once there is a message available, it is popped off the process' message queue. Then, if there was a non-null parameter passed in, it stores the process id of the sending process inside of that pointer. Lastly, the message is converted back into a user message and returned to the user.

\subsubsection{Delayed Send}

\section{Interrupts}\label{sec:interupt}

\subsection{UART}

\subsection{Timers}

\section{System and User Processes}\label{sec:proc}

\subsection{System Processes}

There are three system processes, the Null Process, the CRT Display, and the Keyboard Command Decoder.

\subsubsection{Null Process}

The Null Process runs as an infinite loop of releasing the processor. This process will only execute if all other processes are blocked, or there are no other processes in the system. As a result, this process has a special reserved priority that is the lowest possible in the system. Pseudocode for this process is below.

\begin{code}
while looping forever do
    release the processor
end
\end{code}

\subsubsection{Keyboard Command Decoder}

The Keyboard Command Decode (KCD) is designed to handle both the registration and the parsing of commands from the keyboard. The KCD takes all input in the form of a message from the UART i-process, determines which process corresponds to that command, and sends the command in a message to that process. The initial KCD state will be memory blocked upon first executing. The KCD parses input based on two types of messages, \texttt{DEFAULT} and \texttt{KCD\_REG}.

Default messages are treated as inputted commands, and are parsed by checking to see whether the command registered is contained in the contents of the message. If a command is found in the buffer (denoted by a \% symbol), it is checked against a list of registered commands. Commands are stored and implemented as an array of command structs (see below).
\begin{code}
typedef struct {
    uint32_t pid;
    char cmd[10];
} kcd_cmd_t;
\end{code}

When a command is discovered, it is compared against a command in the list of commands. The operating system assumes that all commands will be at most ten characters, and there will be no more than ten commands registered at any given time. The buffer is then copied into a new message envelope and sent to the process ID of the process that registered the matching command.

KCD registration messages are registered into the command list, along with the sender of the message and the type of command. The message is then released here. Registration with the KCD is done by sending a message of type \texttt{KCD\_REG} to the process with the specific command as the message data. This is then stored into the command list for future use and the memory allocated for the message is released.


\subsubsection{CRT Display}

The CRT Display process is a controller that provides a level of abstraction between the interrupt process and any user process trying to output. This mainly applies to processes that accept command input, such as the wall clock and the priority change process. 

The CRT receives a message and checks if it is of type \texttt{CRT\_DISPLAY}. If it is a valid message, it sends the message to the UART i-process(Section~\ref{sec:interupt}) and triggers a keyboard interrupt to check for messages and perform the print operation. Otherwise, it will release the memory block.

\subsection{User Processes}

These processes can be found inside of \texttt{user\_proc.c}. These processes require registration of commands with the KCD, and only function on user input.

\subsubsection{Wall Clock}

\subsubsection{Change Process Priority}

The change priority process takes a user input command and sets the priority of a specified process to a specified priority when both are valid input. This process functions with the below input into the console by the user.

\begin{code}
\%C [Process ID] [New Priority]
\end{code}

\texttt{Process ID} is the id of the process that will be changed, and ranges from process id 1 to process id 13. This id range excludes the i-processes and the Null Process and they have fixed priorities.

\texttt{New Priority} is the priority that the process will receive. This excludes priority 4 (denoted LOWEST in the priority enumerable) as that priority is reserved for the Null Process.

The change priority process first registers the \%C command with the KCD. It then will wait until it receives a message from the KCD.

The process does several error checks for validation. These include checking for invalid priorities, invalid process ids, process ids that are not numbers and priorities that are not numbers. Checking for valid command format is also done here (i.e. if spaces are used correctly). If the input is invalid, an error message is sent to the CRT for display. Otherwise, the \texttt{set\_process\_priority} method is called with the parsed process id and new priority. This process also outputs all input information to the debug window.

\subsubsection{Stress Test A}

\subsubsection{Stress Test B}

\subsubsection{Stress Test C}

\section{Test Processes}\label{sec:testproc}

\subsection{Process 1}

\subsection{Process 2}

\subsection{Process 3}

\subsection{Process 4}

\subsection{Process 5}

\subsection{Process 6}

\section{Initialization}\label{sec:init}

At the start of the OS, the OS disables interrupts before it initializes the system, otherwise the interrupt handlers cannot run properly. Once everything is initialized properly, it re-enables interrupts and calls the scheduler to dispatch the first process.

\subsection{System APIs}
The first stage of the initialization is to setup the system APIs. First, \texttt{SystemInit()} ic alled to setup the board and the system clock frequency. Second, \texttt{init\_printf(NULL, putc)} is called to enable the use of \texttt{printf} for debugging. Third, \texttt{uart\_irq\_init(0)} enables interrupt-driven I/O on UART0. Fourth, \texttt{uart1\_init()} enables program-driven I/O on UART1 for debugging. Fifth, \texttt{timer\_init(0)} enables the first timer for sending delayed messages. Sixth,  \texttt{timer\_init(1)} enables the second timer for benchmarking. Lastly, \texttt{init\_logo\_on\_lcd()} enables the ability to draw our OS's logo on the LCD display.

\subsection{Memory}

\begin{figure}[h] \label{fig:memory-map}
\caption{Memory Map after Initialization}
\begin{bytefield}{}
    \begin{rightwordgroup}{User Memory Space}
    	\memsection{0x1000 7fff}{0x1000 6000}{4}{16 Process Stacks \\ (each size 0x200)} \\
    	\memsection{}{}{1.5}{-- unused --} \\
    	\memsection{}{}{3}{48 Memory Blocks \\ (each size 0x100)}
    \end{rightwordgroup} \\
    \memsection{0x100 aligned}{}{1.5}{-- unused --} \\
    \begin{rightwordgroup}{Kernel Memory Space}
        \memsection{}{}{1.5}{16 PCBs} \\
        \memsection{}{}{1.5}{16 PCB Nodes} \\
        \memsection{}{}{1.5}{5 Message Blocked Queues} \\
        \memsection{}{}{1.5}{5 Memory Blocked Queues} \\
        \memsection{}{}{1.5}{5 Ready Queues} 
    \end{rightwordgroup}\\
    \memsection{}{}{1.5}{-- 2 word(8 byte) guard --} \\
    \memsection{End of Image}{1000 0000}{3}{Process Image} \\
\end{bytefield}
\end{figure}

After the system APIs have been initialized, the OS then zeros out all of the memory from the end of the system image to the end of RAM with \texttt{0xDEADBEEF}. This makes it easier to debug because if a value after this stage is \texttt{0xDEADBEEF}, then it will be obvious that the value was not properly instantiated. After zeroing out the memory, the OS then dynamically allocates memory for its data structures.  A map of the system memory after initialization is shown on Figure~\ref{fig:memory-map}.

\subsubsection{Kernel Memory Space}

After the process image, the OS dynamically allocates space for all of its kernel's data structures. It first allocates 15 doubly-linked lists to represent 5 ready queues, 5 memory blocked queues, and 5 message blocked queues, one for each process priority. Unlike a traditional linked list implementation, the OS's linked lists do not dynamically allocate and free memory. Instead, the OS simply changes the node pointers because the kernel should never be blocked on memory or get pre-empted while it is running the scheduler. As a result, the OS's PCBs are wrapped with linked list nodes that are preallocated during its initialization stage. In total, the OS allocates 16 PCBs and 16 nodes structures for managing the PCBs.

\subsubsection{User Memory Space}
After the kernel's data structures have been instantiated, the OS then use the space above the PCBs for memory blocks. It first byte aligns the first memory block after the PCBs with \texttt{0x100}. This makes it easier to debug at the cost of at most \texttt{0xFF} memory. From the \texttt{0x100} byte-aligned address, the OS instantiates 48 new \texttt{0x200} doubly linked blocks as shown below (i.e. each block has a pointer to its subsequently and previously instantiated blocks).

\begin{figure}[h] \label{fig:memory-block}
\caption{Memory Block}
\begin{bytefield}{}
    \memsection{0x200}{}{1.5}{\texttt{next}} \\
    \memsection{}{}{1.5}{\texttt{prev}} \\
    \begin{rightwordgroup}{Message Header}
    	\memsection{}{}{6}{-- 4 words (16 bytes) --}
    \end{rightwordgroup} \\
    \begin{rightwordgroup}{User space of size \texttt{0x1E4}}
    	\memsection{0x1E8}{0x4}{8}{\texttt{data}}
    \end{rightwordgroup} \\
    \memsection{}{}{1.5}{\texttt{padding = 0xABAD1DEA}} 
\end{bytefield}
\end{figure}

As shown in Figure~\ref{fig:memory-block}, each memory block is instantiated to be size \texttt{0x200}. However, the OS needs to reserve the top 6 words (24 bytes) for memory and message management (See Section~\ref{sec:ipc} for more information about messages). In addition, the OS reserves the bottom word (4 bytes) as a safety padding to help with debugging. This padding is required because it can detect if a user process writes past their allowable region by verifying the values in the padding. 

Finally, after all of these blocks are initialized, the OS sets the global \texttt{free\_mem} variable to point to the first memory block of this list. 

\subsection{Processes}
After both the kernel and user memory space have been initialized, the OS then moves on to initializing its PCBs with their corresponding process information. First the OS calls the processes' provided initialization methods (e.g. \texttt{set\_test\_procs()}) to fill in its process tables, \texttt{g\_test\_procs}. Each entry of the completed process table contains the corresponding process's pid, priority, and pointer to where the process actually resides in memory. 

After the process tables are filled, the OS then iterates over all the processes in the process tables and initializes its PCBs in a number of steps. First, the \texttt{pid} and \texttt{priority} values are copied into the PCB. Second, the PCB state is set to \texttt{NEW}. Third, the PCB's message queue is initialized to be an empty linked list. Fourth, it initializes the process's stack (see Section~\ref{sec:setting-up-stack}). Lastly, it sets \texttt{stack\_ptr} to the appropriate location.
	
Although the i-processes do not need a stack because they rely on the kernel's stack whenever they run, it makes initialization simpler because the loop does not need to check process types. In addition, it was also of no consequence because there is still leftover space between the stacks and memory blocks.

\subsubsection{Setting up the Stack} \label{sec:setting-up-stack}

As specified in the board's documentation, to go from handler mode to thread mode, the OS uses the \texttt{BL 0xFFFF FFF9} instruction. This special instruction pops values off the stack frame, as shown in Figure~\ref{fig:stack-after-branch}, and copies them into their corresponding registers.
	
\begin{figure} \label{fig:stack-after-branch}
\caption{Stack after calling \texttt{BL 0xFFFF FFF9}}
\begin{bytefield}[rightcurly=.]{}
	\begin{rightwordgroup}{$\leftarrow$ SP is here after resuming to thread mode}
		\memsection{}{}{1.5}{-- NULL --} 
	\end{rightwordgroup} \\
	\memsection{}{}{1.5}{xPSR = \texttt{0x1000 0000}} \\
	\memsection{}{}{1.5}{PC = \texttt{proc\_start}} \\
    \memsection{}{}{1.5}{LR = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R12 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R3 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R2 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R1 = \texttt{0x0}} \\
	\begin{rightwordgroup}{$\leftarrow$ SP initially points here in handler mode}
		\memsection{}{}{1.5}{R0 = \texttt{0x0}}
	\end{rightwordgroup} \\
\end{bytefield}
\end{figure}
	
Normally, these values are automatically set when the user makes a system call from thread mode. However because the OS is initialized in handler mode, it needs to manually set default values the first time it runs so that the scheduler does not hard fault. In other words, the OS writes the default values to the stack as show in Figure~\ref{fig:stack-after-branch} and sets \texttt{stack\_ptr} to point 8 words below the start of the stack.

\section{Testing}\label{sec:test}

\subsection{Verification}

\subsection{Debugging}

\section{Major Design Challenges}\label{sec:design}

\subsection{Mistakes}

\subsection{Stumbling Blocks}

\subsection{Things To Change}

\subsection{Design Issues}

\subsection{Group Challenges}

\section{Timing Analysis}\label{sec:time}

\end{document}
