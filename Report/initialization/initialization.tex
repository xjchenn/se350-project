\documentclass[12pt]{article}
\pagestyle{empty}

\usepackage{amsmath}
\usepackage{scrextend}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{tkz-graph}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{bytefield}
\usepackage{listings,color}
\usepackage{float}

\setlength{\parindent}{24pt}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{code}{%
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

% http://www.martin-demling.de/2011/06/memory-maps-in-latex-using-the-bytefield-package/
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip} % define the height of the memsection
	\bitbox[]{10}{
		\texttt{#1} % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{#2} % print start address
	}
	\bitbox{16}{#4} % print box with caption
}

\begin{document}

\section{Initialization}


\subsection{System APIs}


\subsubsection{printf}


\subsubsection{UART0}


\subsubsection{UART1}


\subsubsection{Timer}


\subsubsection{LCD Display}


\subsection{Memory}
After the system APIs have been initialized, we then initialize and allocate our system memory. We do this before any of our other code runs because the OS itself only contains pointers to our data structures. Since our data structures have not been allocated at this stage, they will either hard fault or experience nondeterministic behaviour. The entire memory map of our system after this initialization step is shown on Figure~\ref{fig:memory-map}. 

\subsubsection{Kernel Memory Space}

After the process image, we dynamically allocate space for all of our kernel's data structures. We chose to allocate our data structures dynamically instead of at compile time because we are first "zeroing" out our entire memory space from \texttt{0x10008000} down to the end of our image with \texttt{0xDEADBEEF}. This makes it easier to debug faults because if any registers (especially the link register) is \texttt{0xDEADBEEF} instead of 0 or some other random value, then we will instantly know that it's caused by uninitialized memory. In our kernel space, we have the following data structures initialized:

\begin{itemize}
	\item \textbf{5 Ready, 5 memory blocked, and 5 message blocked queues:} 
	
	For each state that needs a queue (ready, memory blocked, and message blocked), we have one queue for each priority and each queue is implemented as a doubly-linked list:
	\begin{code}
linkedlist_t
    node_t* first;
    node_t* last;
    int length;
	\end{code}
	
	\item \textbf{16 PCB Nodes:} (one for each PCB)
	
	Unlike a traditional linked list implementation, our linked list does not dynamically allocate and free memory. Instead, our implementation simply changes the pointers because we do not want our kernel to be blocked on memory or get pre-empted while it's running the scheduler. We wrapped our PCB struct with this node instead of putting the next and previous pointers inside the PCB itself was because we wanted the linked list to be generic enough for other kernel features (such as the process message queues).
	\begin{code}
node_t
    node_t* next;
    node_t* prev;
    void* value;
	\end{code}
	
	\item \textbf{16 PCBs:} (one for each process)
	
	Our PCBs themselves contain all of the information that the kernel needs to know about a process.
	\begin{code}
pcb_t
    uint32_t pid;
    PROCESS_STATE state;
    uint32_t priority;
    uint32_t* stack_ptr;
    linkedlist_t msg_queue;
	\end{code}
	
	The \texttt{PROCESS\_STATE} is a enum that we use to keep track of the current state. Currently we have 6 states: new, ready, running, memory blocked, message blocked, and exit. 
	
\end{itemize}

\subsubsection{User Memory Space}
After we finish initializing our kernel's memory space, we then use the space above the PCBs for our memory blocks. However, before we initialize the memory blocks, we first byte align our heap pointer after the PCBs with \texttt{0x100}. This will make it easier to debug with the memory window at the cost of at most 0xFF memory.

The memory blocks themselves have the same "header" as a regular node because we can then cast the memory blocks to nodes and reuse our linked list implementation. See Section~TODO for more details about the memory blocks.
\begin{code}
mem_blk_t
    mem_blk_t* next;
    mem_blk_t* prev;
    void* data;
    uint32_t padding;
\end{code}

\subsubsection{Process Stacks}
After the memory blocks have been initialized, we then start from the top of the available RAM for our processes' stacks, each with a size of \texttt{0x200}. Although the i-processes does not actually need a stack because it's working off the kernel stack when it gets invoked, it makes initialization easier because we have have a generic loop rather than one that checks for every process types. It's also at no cost to us because we still have leftover free space in our RAM in the end. 

\begin{figure}[H]
\centering
\label{fig:memory-map}

\begin{bytefield}{}
    \begin{rightwordgroup}{User Memory Space}
    	\memsection{1000 7fff}{1000 6000}{10}{16 Process Stacks \\ (each size 0x200)} \\
    	\memsection{}{}{5}{-- unused --} \\
    	\memsection{}{}{10}{48 Memory Blocks \\ (each size 0x100)}
    \end{rightwordgroup} \\
    \begin{rightwordgroup}{Kernel Memory Space}
        \memsection{}{}{2}{16 PCBs} \\
        \memsection{}{}{2}{16 PCB Nodes} \\
        \memsection{}{}{2}{5 Message Blocked Queues} \\
        \memsection{}{}{2}{5 Memory Blocked Queues} \\
        \memsection{}{}{2}{5 Ready Queues} 
    \end{rightwordgroup}\\
    \memsection{}{}{2}{-- 8-byte Guard --} \\
    \memsection{End of Image}{1000 0000}{5}{Process Image} \\
\end{bytefield}
\caption{Memory Map}

\end{figure}

\subsection{Processor}


\end{document}