% uw-wkrpt-se.tex - An example work report that uses uw-wkrpt.cls
% Copyright (C) 2002,2003  Simon Law
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% We begin by calling the workreport class which includes all the
% definitions for the macros we will use.
\documentclass[se]{uw-wkrpt}

% LaTeX preamble: load some packages to add functionality
\usepackage{graphicx} % Include graphic importing

\usepackage[T1]{fontenc} % Better fonts
\usepackage{ae,aecompl}

\usepackage{indentfirst} % Indent first paragraph of each section

\usepackage[titletoc,title]{appendix} % Prefix appendix letters with `Appendix'

\usepackage{amsmath}
%\usepackage{scrextend}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{tkz-graph}
\usepackage{parskip}
\usepackage{enumitem}
\usepackage{bytefield}
\usepackage{listings,color}
\usepackage{float}


% Use the algorithmicx package for pseudocode
\usepackage{algorithm}
\usepackage{algpseudocode}

% Use biblatex for references
\usepackage[style=ieee,sorting=none,dateabbrev=false,backend=biber]{biblatex}
\addbibresource{uw-wkrpt-bib.bib} % Specify the bibliography file

% This needs to be the last package loaded
\usepackage[pdftex]{hyperref} % Generate PDF links and bookmarks.
\hypersetup{
  bookmarks=true,
  bookmarksnumbered=true
}

\definecolor{verbgray}{gray}{0.9}

\lstnewenvironment{code}{%
  \lstset{backgroundcolor=\color{verbgray},
  frame=single,
  framerule=0pt,
  basicstyle=\ttfamily,
  columns=fullflexible}}{}

% http://www.martin-demling.de/2011/06/memory-maps-in-latex-using-the-bytefield-package/
\newcommand{\memsection}[4]{
	\bytefieldsetup{bitheight=#3\baselineskip} % define the height of the memsection
	\bitbox[]{10}{
		\texttt{#1} % print end address
		\\ \vspace{#3\baselineskip} \vspace{-2\baselineskip} \vspace{-#3pt} % do some spacing
		\texttt{#2} % print start address
	}
	\bitbox{16}{#4} % print box with caption
}


% Now we will begin writing the document.
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IMPORTANT INFORMATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% First we, should create a title page.  This is done below:
% Fill in the title of your report.
\title{OS WOW RTX Documentation}

% Fill in your name.
\author{Fasih Awan, Joshua Kalpin, Si Chuang Li, John Zanutto}

% Fill in your student ID number.
\uwid{20414848, 20414492, 20413578, TODO}

% Fill in the name of the PNG file with your signature, or leave unchanged.
\signature{signature}

% Fill in your home address.
\address{123 University Ave. W.\\*
         Waterloo, ON\ \ N2L 3G1}

% Fill in your employer's name.
\employer{SE 350}

% Fill in your employer's city and province.
\employeraddress{Thomas Reidemeister}

% Fill in your school's name.
\school{University of Waterloo}

% Fill in your faculty name.
\faculty{Software Engineering}

% Fill in your student user ID
\userid{fawan, jkalpin, sc6li, jzanutto}

% Fill in your e-mail address.
\email{jrhacker@engmail}

% Fill in your term.
\term{3A}

% Fill in your program.
\program{Software Engineering}

% Fill in the department chair's name.
\chair{Dr.\ A.\ Morton}

% Fill in the department chair's mailing address.
\chairaddress{Software Engineering\\*
              University of Waterloo\\*
	      Waterloo, ON\ \ N2L 3G1}

% If you are writing an "SE-confidential" report, uncomment the next line.
%\confidential{SE-confidential}

% If you want to specify the date, fill it in here.  If you comment out
% this line, today's date will be substituted.
%\date{April 24, 2012}

% Now, we ask LaTeX to generate the title.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FRONT MATTER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \frontmatter will make the \section commands ignore their numbering,
%% it will also use roman page numbers.
\frontmatter

% We continue with required sections, such as the Executive Summary.
\section{Executive Summary}
TODO

% Next, we need to make a Table of Contents, List of Figures and 
% List of Tables.  You will most likely need to run LaTeX twice to
% get these correct.  The first pass for LaTeX to figure out the
% labels, and the second pass to put in the right references.
\tableofcontents
\listoffigures
\listoftables

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% REPORT BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \main will make the \section commands numbered again,
%% it will also use arabic page numbers.
\mainmatter

% You must have an Introduction
\section{Introduction}\label{sec:intro}

\subsection{About}

This report is a detailed design document describing the OS WOW Real-Time Operation System designed by Fasih Awan, Joshua Kalpin, John Zanutto and Si Chuang Li. This operating system was implemented for the Keil MCB1700 board populated with an NXP LPC1768 microcontroller. 

This operating system was created over the span of three months during the creator's 3A term in Software Engineering. It was developed in four parts adding more features each time. The first part involved creating basic memory management and process handling. The second part added the challenge of interrupts and a console. The third part added more processes. Lastly, the fourth part of the project included timing tests and this report.

\subsection{Purpose}

The purpose of this report is to provide the reader with detailed documentation on the OS WOW operating system. This includes the following information. First, the data structures and global variables that the kernel uses. Second, this report will document the APIs that are available to user's of the operation system. Third, details on how interrupts are handled within the operating system will be specified. Fourth, the various system, user and test processes will be explained. Fifth, details on how the operating system is initialized, including memory and processes will be provided. Lastly, there will be details on testing, design challenges and timing analysis on the functions of the operating system.

\section{Global Variables}\label{sec:global}

\subsection{Linked Lists}

\subsection{Memory}

\subsection{Processes}

\subsection{Timers}

\subsection{Inter-Process Communication}

\section{Kernel API} \label{sec:kernel}

\subsection{Memory}

The kernel keeps track of the available memory with a global pointer \texttt{free\_mem} that points to the first block of the list of free memory blocks. Whenever a memory block is requested, the front of this list is removed (if the list is not empty) and is given to the requester. Whenever a memory block is released, the given block is added to the front of this list.

\subsubsection{Request Memory}
\begin{code}
void* request_memory_block()
\end{code}

This method takes zero arguments and returns an address to a piece of memory that the caller can use. The returned address points to a continuous block of memory of size \texttt{0x1E4} bytes that the current process can read and write to. Currently, the memory protection unit is disabled so if the process reads or writes outside of \texttt{returned address + 0x1E4}, then undefined behaviour will occur.

If the system is out of memory, then the calling process will be pre-empted and will be placed on its priority's memory blocked queue until more memory becomes available (i.e. when another process releases their memory). It is recommended that once the user is finished with their allocated block that they release it otherwise the system will run out of memory very quickly. See Section~\ref{sec:release-memory-block} for more information about releasing memory blocks.

\subsubsection{Release Memory}
\label{sec:release-memory-block}
\begin{code}
int32_t release_memory_block(void*)
\end{code}

This method takes in a pointer returned by \texttt{request\_memory\_block()}, deallocates it, and returns 0 if successful. If there was an error or if the pointer was invalid such as NULL or out of the range of the RAM, this method returns -1. This method also checks if there are currently any processes blocked on memory with a priority greater than or equal to the calling process. If so, then the current process will get pre-empted and the scheduler will get called instead of continuing with the current process.

\subsubsection{Example Usage of Requesting and Releasing Memory}
\begin{code}
void example_process(void) {
    int* array;
    
    while (1) {
        array = (int*) request_memory_block();
        array[0] = 0xDEADC0DE;
        release_memory_block(array);
    }
}
\end{code}

\subsection{Process Management}

\subsection{Inter-Process Communcation} \label{sec:ipc}

\subsubsection{Send Message}

\subsubsection{Receive Message}

\subsubsection{Delayed Send}

\section{Interrupts}\label{sec:interupt}

\subsection{UART}

\subsection{Timers}

\section{System and User Processes}\label{sec:proc}

\subsection{System Processes}


\subsubsection{Keyboard Command Decoder}

\subsubsection{CRT Display}

\subsection{User Processes}

\subsubsection{Wall Clock}

\subsubsection{Stress Test A}

\subsubsection{Stress Test B}

\subsubsection{Stress Test C}

\section{Test Processes}\label{sec:testproc}

\subsection{Process 1}

\subsection{Process 2}

\subsection{Process 3}

\subsection{Process 4}

\subsection{Process 5}

\subsection{Process 6}

\section{Initialization}\label{sec:init}

At the start of the OS, the OS disables interrupts before it initializes the system, otherwise the interrupt handlers cannot run properly. Once everything is initialized properly, it re-enables interrupts and calls the scheduler to dispatch the first process.

\subsection{System APIs}
The first stage of the initialization is to setup the system APIs. The OS calls: \texttt{SystemInit()} to setup the board and the system clock frequency; \texttt{init\_printf(NULL, putc)} to enable the use of \texttt{printf} for debugging; \texttt{uart\_irq\_init(0)} to enable interrupt-driven I/O on UART0; \texttt{uart1\_init()} to use program-driven I/O on UART1 for debugging; \texttt{timer\_init(0)} to enable the first timer for sending delayed messages;  \texttt{timer\_init(1)} to enable the second timer for benchmarking; and \texttt{init\_logo\_on\_lcd()} to draw our OS's logo on the LCD display.

\subsection{Memory}

\begin{figure} \label{fig:memory-map}
\caption{Memory Map after Initialization}
\begin{bytefield}{}
    \begin{rightwordgroup}{User Memory Space}
    	\memsection{0x1000 7fff}{0x1000 6000}{6}{16 Process Stacks \\ (each size 0x200)} \\
    	\memsection{}{}{3}{-- unused --} \\
    	\memsection{}{}{9}{48 Memory Blocks \\ (each size 0x100)}
    \end{rightwordgroup} \\
    \memsection{0x100 aligned}{}{3}{-- unused --} \\
    \begin{rightwordgroup}{Kernel Memory Space}
        \memsection{}{}{1.5}{16 PCBs} \\
        \memsection{}{}{1.5}{16 PCB Nodes} \\
        \memsection{}{}{1.5}{5 Message Blocked Queues} \\
        \memsection{}{}{1.5}{5 Memory Blocked Queues} \\
        \memsection{}{}{1.5}{5 Ready Queues} 
    \end{rightwordgroup}\\
    \memsection{}{}{1.5}{-- 2 word(8 byte) guard --} \\
    \memsection{End of Image}{1000 0000}{4}{Process Image} \\
\end{bytefield}
\end{figure}

After the system APIs have been initialized, the OS then zeros out all of the memory from the end of the system image to the end of RAM with \texttt{0xDEADBEEF}. This makes it easier to debug because if a value after this stage is \texttt{0xDEADBEEF}, then it will be obvious that the value was not properly instantiated. After zeroing out the memory, the OS then dynamically allocates memory for its data structures. This is before anything else runs because the OS itself only contains pointers to its data structures. A map of the system memory after initialization is shown on Figure~\ref{fig:memory-map}.

\subsubsection{Kernel Memory Space}

After the process image, the OS dynamically allocates space for all of its kernel's data structures. It first allocates 15 doubly-linked lists to represent 5 ready queues, 5 memory blocked queues, and 5 message blocked queues (one for each priority). Unlike a traditional linked list implementation, the OS's linked lists do not dynamically allocate and free memory. Instead, the OS simply changes the node pointers because the kernel should never be blocked on memory or get pre-empted while it is running the scheduler. As a result, the OS's PCBs are wrapped with linked list nodes that are preallocated during its initialization stage. In total, the OS allocates 16 PCBs and 16 nodes structures for managing the PCBs.

\subsubsection{User Memory Space}
After the kernel's data structures have been instantiated, the OS then use the space above the PCBs for memory blocks. It first byte aligns the first memory block after the PCBs with \texttt{0x100}. This makes it easier to debug at the cost of at most \texttt{0xFF} memory. From the \texttt{0x100} byte-aligned address, the OS instantiates 48 new \texttt{0x200} doubly linked blocks as shown below (i.e. each block has a pointer to its subsequently and previously instantiated blocks).

\begin{figure} \label{fig:memory-block}
\caption{Memory Block}
\begin{bytefield}{}
    \memsection{0x200}{}{1.5}{\texttt{next}} \\
    \memsection{}{}{1.5}{\texttt{prev}} \\
    \begin{rightwordgroup}{Message Header}
    	\memsection{}{}{6}{-- 4 words (16 bytes) --}
    \end{rightwordgroup} \\
    \begin{rightwordgroup}{User space of size \texttt{0x1E4}}
    	\memsection{0x1E8}{0x4}{8}{\texttt{data}}
    \end{rightwordgroup} \\
    \memsection{}{}{1.5}{\texttt{padding = 0xABAD1DEA}} 
\end{bytefield}
\end{figure}

As shown in Figure~\ref{fig:memory-block}, each memory block is instantiated to be size \texttt{0x200}. However, the OS needs to reserve the top 6 words (24 bytes) for memory and message management (See Section~\ref{sec:ipc} for more information about messages). In addition, the OS reserves the bottom word (4 bytes) as a safety padding to help with debugging because if a user process writes past their allowable region, then this padding will not have the default value any more. 

Finally, after all of these blocks are initialized, the OS sets the global \texttt{free\_mem} variable to point to the first memory block of this list. 

\subsection{Processes}
After both the kernel and user memory space have been initialized, the OS then moves on to initializing its PCBs with their corresponding process information. First the OS calls the processes' provided methods (such as \texttt{set\_test\_procs()}) to fill in its process tables (such as \texttt{g\_test\_procs}). Each entry of the completed process table contains the corresponding process's pid, priority, and pointer to where the process actually resides in memory. 

After the process tables are filled, the OS then iterates over all the processes in the process tables and initializes its PCBs: copies the \texttt{pid} and \texttt{priority} into the PCB; sets the PCB state to \texttt{NEW}; instantiates the PCB's message queue to be an empty linked list; initializes the process's stack (see Section~\ref{sec:setting-up-stack}); and sets \texttt{stack\_ptr} to the appropriate location.
	
Although the i-processes do not actually need a stack because they will be using the kernel's stack whenever they run, it makes initialization a lot easier because the loop does not need to check process types. In addition, it was also of no consequence because there are still leftover space in the end between the stacks and memory blocks.

\subsubsection{Setting up the Stack} \label{sec:setting-up-stack}

As specified in the board's documentation, to go from handler mode (scheduler) to thread mode (a user process), the OS uses the \texttt{BL 0xFFFF FFF9} instruction. This special instruction pops values off the stack frame, as shown in Figure~\ref{fig:stack-after-branch}, and copies them into their corresponding registers.
	
\begin{figure} \label{fig:stack-after-branch}
\caption{Stack after calling \texttt{BL 0xFFFF FFF9}}
\begin{bytefield}[rightcurly=.]{}
	\begin{rightwordgroup}{$\leftarrow$ SP is here after resuming to thread mode}
		\memsection{}{}{1.5}{-- NULL --} 
	\end{rightwordgroup} \\
	\memsection{}{}{1.5}{xPSR = \texttt{0x1000 0000}} \\
	\memsection{}{}{1.5}{PC = \texttt{proc\_start}} \\
    \memsection{}{}{1.5}{LR = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R12 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R3 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R2 = \texttt{0x0}} \\
    \memsection{}{}{1.5}{R1 = \texttt{0x0}} \\
	\begin{rightwordgroup}{$\leftarrow$ SP initially points here in handler mode}
		\memsection{}{}{1.5}{R0 = \texttt{0x0}}
	\end{rightwordgroup} \\
\end{bytefield}
\end{figure}
	
Normally, these values are automatically set when the user makes a system call from thread mode. However because the OS is initialized in handler mode, it needs to manually set these default values (as shown above) the first time so that the scheduler don't hard fault. Therefore, the OS writes the default values to the stack as show in Figure~\ref{fig:stack-after-branch} and sets \texttt{stack\_ptr} to point 8 words below the start of the stack.

\section{Testing}\label{sec:test}

\subsection{Verification}

\subsection{Debugging}

\section{Major Design Challenges}\label{sec:design}

\subsection{Mistakes}

\subsection{Stumbling Blocks}

\subsection{Things To Change}

\subsection{Design Issues}

\subsection{Group Challenges}

\section{Timing Analysis}\label{sec:time}

\end{document}
